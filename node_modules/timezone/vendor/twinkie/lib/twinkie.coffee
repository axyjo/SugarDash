fs = require "fs"
{spawn,exec} = require "child_process"

DESCRIPTION =
  compile:        "compile the CoffeeScript into JavaScript"
  gitignore:      "create a .gitignore for node-ec2 based on git branch"
  docco:          "rebuild the CoffeeScript docco documentation"
  idl:            "rebuild the Node IDL landing page"
  configuration:  "create a server configuration"
  watch:          "watch for changes, compile and restart server"

isDirty = (source, output) ->
  try
    fs.statSync(source).mtime > fs.statSync(output).mtime
  catch e
    true

# Cheap make. Why not use real make? Because real make solves a more complicated
# problem, building an artifact that has multiple dependencies, which in turn
# have dependencies. Here we build artifacts that each have a single dependency,
# that is we build a JavaScript file from a single CoffeeScript file.
class module.exports.Twinkie
  constructor: ->
    @steps = []
    @sources = []
    @ignores = []
    @_master = "master"

  master: (master) ->
    @_master = master

  ignore: (files...) ->
    for file in files
      @ignores.push file

  gitignore: ->
    @currentBranch (branch) =>
      gitignore = '''
                  .gitignore
                  lib-cov
                  .DS_Store
                  .AppleDouble
                  *.swp
                  '''
      gitignore = "#{[ gitignore ].concat(@ignores).join("\n")}\n"

      if branch is "gh-pages"
        gitignore += '''
                     lib/*
                     '''
      else if branch is @_master
        gitignore += '''
                     documentation
                     site
                     index.html
                     lib/*
                     '''
      fs.writeFile(".gitignore", gitignore)

  # Get the current git branch.
  currentBranch: (callback) ->
    branches = ""
    git = spawn "git", [ "branch" ], { customFds: [ 0, -1, 2 ] }
    git.stdout.on "data", (buffer) -> branches += buffer.toString()
    git.on "exit", (status) ->
      process.exit 1 if status != 0
      branch = /\*\s+(.*)/.exec(branches)[1]
      callback branch

  # Generate Docco documentation.
  docco: ->
    exec "rm -rf documentation && docco src/lib/*.coffee && cp -rf docs documentation && rm -r docs", (err) ->
      throw err if err

  # Generate Node IDL documentation.
  idl: ->
    idl       = require("idl")
    package   = JSON.parse fs.readFileSync "package.json", "utf8"
    idl.generate "#{package.name}.idl", "index.html"

  coverage: ->
    expresso = spawn "expresso", [ "coverage.js", "--coverage" ], { customFds: [ 0, 1, 2 ] }
    expresso.on "exit", (status) -> process.exit(1) if status != 0

  mkdir: (dirs...)  ->
    @steps.push (commands) ->
      for dir in dirs
        commands.push [ "mkdir", [ "-p", "-m", "755", dir ] ]

  copy: (from, to, include, exclude) ->
    find = (commands, from, to) ->
      # Gather up the CoffeeScript files and directories in the source directory.
      files = []
      dirs = []
      for file in fs.readdirSync from
        source = "#{from}/#{file}"
        if include.test(source) and not (exclude and exclude.test(source))
          try
            if fs.statSync(source).mtime > fs.statSync("#{to}/#{file}").mtime
              files.push source
          catch e
            files.push source
        else
          try
            stat = fs.statSync "#{from}/#{file}"
            if stat.isDirectory()
              dirs.push file # Create the destination directory if it does not exist.
          catch e
            console.warn "Cannot stat: #{from}/#{file}"
            throw e if e.number != process.binding("net").ENOENT
            console.warn "File disappeared: #{from}/#{file}"
      if files.length
        try
          fs.statSync to
        catch e
          path = to.split /\//
          for i in [0..path.length]
            try
              fs.mkdirSync path[0..i].join("/"), parseInt(755, 8)
            catch e
              throw e if e.code isnt "EEXIST"
        commands.push [ "cp", files.concat(to) ]

      for dir in dirs
        continue if /^\./.test dir
        find commands, "#{from}/#{dir}",  "#{to}/#{dir}"
    @steps.push (commands) -> find commands, from, to

  # Cheap `make`. Why not use real `make`? Because real make solves a more
  # complicated problem, building an artifact that has multiple dependencies,
  # which in turn have dependencies. Here we build artifacts that each have a
  # single dependency; a JavaScript file build from a CoffeeScript file.
  coffee: (from, to) ->
    find = (commands, from, to) ->
      # Gather up the CoffeeScript files and directories in the source directory.
      files = []
      dirs = []
      try
        for file in fs.readdirSync from
          if match = /^(.*).coffee$/.exec(file)
            stat = null
            file = match[1]
            source = "#{from}/#{file}.coffee"
            try
              try
                stat = fs.statSync("#{to}/#{file}.js")
               catch e
                throw e if e.number != process.binding("net").ENOENT
                try
                  stat = fs.statSync("#{to}/#{file}")
                catch e
                  throw e if e.number != process.binding("net").ENOENT
              if not stat or fs.statSync(source).mtime > stat.mtime
                files.push source
            catch e
              throw e if e.number != process.binding("net").ENOENT
              files.push source
          else
            try
              stat = fs.statSync "#{from}/#{file}"
              if stat.isDirectory()
                dirs.push file
            catch e
              console.log "Gee Wilikers."
      catch e
        throw e if e.number != process.binding("net").ENOENT

      # Create the destination directory if it does not exist.
      if files.length
        try
          fs.statSync to
        catch e
          path = to.split /\//
          for i in [0..path.length]
            try
              fs.mkdirSync path[0..i].join("/"), parseInt(755, 8)
            catch e
              throw e if e.code isnt "EEXIST"
        commands.push [ "coffee", "-c -o #{to}".split(/\s/).concat(files) ]

      for dir in dirs
        continue if /^\./.test dir
        find commands, "#{from}/#{dir}",  "#{to}/#{dir}"
    @steps.push (commands) -> find commands, from, to

  ejs: (from, to) ->
    find = (from, to) ->
      dirs = []
      for file in fs.readdirSync from
        if match = /^(.*).ui$/.exec(file)
          dirty = false
          file = match[1]
          listing = "#{from}/#{file}.ui"
          output = "#{to}/#{file}_ui.js"
          if not dirty = isDirty(listing, output)
            for line in fs.readFileSync(listing, "utf8").split(/\n/)
              continue unless line = line.trim()
              source = "#{from}/#{line}"
              if dirty = isDirty("#{from}/#{line}", output)
                break
          if dirty
            try
              fs.statSync to
            catch e
              fs.mkdirSync to, parseInt(755, 8)
            templates = {}
            for line in fs.readFileSync(listing, "utf8").split(/\n/)
              continue unless line = line.trim()
              templates[/([^\/]+).ejs$/.exec(line)[1]] = fs.readFileSync("#{from}/#{line}", "utf8")
            fs.writeFileSync output, "var templates = #{JSON.stringify(templates, null, 2)};", "utf8"
        else
          try
            stat = fs.statSync "#{from}/#{file}"
            if stat.isDirectory()
              dirs.push file
          catch e
            console.warn "Cannot stat: #{from}/#{file}"
            throw e if e.number != process.binding("net").ENOENT
            console.warn "File disappeared: #{from}/#{file}"

      for dir in dirs
        find "#{from}/#{dir}",  "#{to}/#{dir}"
    @steps.push (commands) -> find from, to

  peg: (from, to) ->
    find = (commands, from, to) ->
      files = []
      dirs = []
      for file in fs.readdirSync from
        if match = /^(.*).pegjs$/.exec(file)
          file = match[1]
          source = "#{from}/#{file}.pegjs"
          try
            if fs.statSync(source).mtime > fs.statSync("#{to}/#{file}.js").mtime
              files.push source
          catch e
            files.push source
        else
          try
            stat = fs.statSync "#{from}/#{file}"
            if stat.isDirectory()
              dirs.push file
          catch e
            throw e if e.number != process.binding("net").ENOENT

      # Create the destination directory if it does not exist.
      if files.length
        try
          fs.statSync to
        catch e
          fs.mkdirSync to, parseInt(755, 8)
        for file in files
          [ path, base ] = /^(.*)\/(.*).pegjs$/.exec(file).slice(1)
          parser = require("pegjs").buildParser(fs.readFileSync(file, "utf8"))
          fs.writeFileSync("#{to}/#{base}.js", "module.exports.parser = #{parser.toSource()}", "utf8")

      # Compile the files, then move onto the child directories.
      for dir in dirs
        continue if /^\./.test dir
        find "#{from}/#{dir}",  "#{to}/#{dir}"
    @steps.push (commands) -> find commands, from, to

  less: (from, to) ->
    find = (commands, from, to) ->
      # Gather up the CoffeeScript files and directories in the source directory.
      files = []
      dirs = []
      for file in fs.readdirSync from
        if match = /^(.*).less$/.exec(file)
          file = match[1]
          source = "#{from}/#{file}.less"
          try
            if fs.statSync(source).mtime > fs.statSync("#{to}/#{file}.css").mtime
              files.push source
          catch e
            files.push source
        else
          try
            stat = fs.statSync "#{from}/#{file}"
            if stat.isDirectory()
              dirs.push file
          catch e
            throw e if e.number != process.binding("net").ENOENT

      # Create the destination directory if it does not exist.
      if files.length
        try
          fs.statSync to
        catch e
          fs.mkdirSync to, parseInt(755, 8)
        for file in files
          [ path, base ] = /^(.*)\/(.*).less$/.exec(file).slice(1)
          commands.push [ "lessc", [ source, "#{to}/#{base}.css" ] ]

      # Compile the files, then move onto the child directories.
      for dir in dirs
        continue if /^\./.test dir
        find "#{from}/#{dir}",  "#{to}/#{dir}"
    @steps.push (commands) -> find commands, from, to

  runCompile: (callback) ->
    commands = []
    index = 0
    for step in @steps
      step(commands)
    next = =>
      if commands.length is 0
        callback() if callback
      else
        command = commands.shift()
        command.push { customFds: [ 0, 1, 2 ] }
        program = spawn.apply null, command
        program.on "exit", (code) ->
          process.exit(code) unless code is 0
          next()
    next()

  compile: -> @runCompile()

  configuration: ->
    configuration =
      { "address": "0.0.0.0"
      , "app": "#{process.env["HOME"]}/git/ecma/woof"
      , "ports":
        [ 8018
        , 9004
        , 9005
        , 9006
        , 9011
        , 9012
        , 9013
        ]
      , "var": "/home/u10001/var"
      , "tmp": "/home/u10001/tmp"
      , "databases":
        { "mysql":
          { "name": "adva_production"
          , "alias": "mysql"
          , "user": "adva_production"
          , "engine": "mysql"
          , "password": "adva_production"
          , "hostname": "localhost"
          , "port": 3306
          }
        }
      }
    fs.writeFileSync "configuration.json", JSON.stringify configuration, null, 2

  source: (exclude, splat...) ->
    find = (sources, search) ->
      [ dirs, files ] = [ [], [] ]
      for dir in search
        for file in fs.readdirSync dir
          try
            full = "#{dir}/#{file}"
            stat = fs.statSync(full)
            if stat.isDirectory()
              dirs.push full
            else if not exclude.test(full)
              files.push full
          catch e
            throw e if e.number != process.binding("net").ENOENT
      for file in files
        sources[file] = true
      if dirs.length
        find sources, dirs
    @sources.push (sources) -> find sources, splat

  watch: ->
    @server = null
    process.on "exit", =>
      @server.kill() if @server
    status = invoke "compile"
    restart = =>
      @server = spawn "node", [ "server.js" ], { customFds: [ 0, 1, 2 ] }
      @server.on "exit", (code) =>
        @server = null
        @runCompile =>
          restart()
          process.stderr.write "\u0007### RESTARTED #{new Array(70).join("#")}\n"
    @runCompile =>
      restart()
      update = (current, previous) =>
        if current.mtime.getTime() != previous.mtime.getTime()
          process.stderr.write "#{current.mtime} != #{previous.mtime} inode #{current.ino} #{previous.ino}\n"
          @server.kill()
      sources = {}
      for find in @sources
        find sources
      for file of sources
        fs.watchFile file, update

  clean: ->
    @currentBranch (branch) =>
      if branch is "master"
        rm = spawn "/bin/rm", "-rf site documentation lib/packet.js lib/pattern.js".split(/\s+/), { customFds: [ 0, 1, 2 ] }
        rm.on "exit", (code) ->
          process.exit code if code

  tasks: (task, tasks...) ->
    for name in tasks
      task name, DESCRIPTION[task] or "", do (name) => => @[name]()

# Work this into the object above.
shebang = (shebang, files...) ->
  for file in files
    try
      program = file.replace /^(.*)\/(.*?)\..*$/, "$1/$2"
      contents = "#{shebang}\n#{fs.readFileSync file, "utf8"}"
      fs.writeFileSync program, contents, "utf8"
      fs.chmodSync program, 0755
      fs.unlinkSync file
    catch e
      throw e if e.number != process.binding("net").ENOENT
      continue
