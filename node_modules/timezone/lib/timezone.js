(function() {
  var __slice = Array.prototype.slice;
  (function() {
    return (exports || (exports = window)) && (function(exports) {
      var DAY, HOUR, LOCALES, MINUTE, SECOND, TIMEZONES, adjust, convertToUTC, convertToWallclock, convertUntil, daysInMonth, format, isLeapYear, makeDate, offsetInMilliseconds, parse, ruleToDate, summerRule, tz;
      TIMEZONES = {
        zones: {
          UTC: [
            {
              "offset": "0",
              "format": "UTC"
            }
          ]
        },
        rules: {}
      };
      TIMEZONES.zones.UTC.name = "UTC";
      LOCALES = {
        en_US: {
          name: "en_US",
          day: {
            abbrev: "Sun Mon Tue Wed Thu Fri Sat".split(/\s/),
            full: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(/\s+/)
          },
          month: {
            abbrev: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(/\s+/),
            full: "January February March\nApril   May      June\nJuly    August   September\nOctober November December".split(/\s+/)
          },
          dateFormat: "%m/%d/%Y",
          timeFormat: "%I:%M:%S %p",
          dateTimeFormat: "%a %d %b %Y %I:%M:%S %p %Z",
          meridiem: [
            {
              lower: "am",
              upper: "AM"
            }, {
              lower: "pm",
              upper: "PM"
            }
          ],
          monthBeforeDate: true
        }
      };
      SECOND = 1000;
      MINUTE = SECOND * 60;
      HOUR = MINUTE * 60;
      DAY = HOUR * 24;
      isLeapYear = function(year) {
        if (year % 400 === 0) {
          return true;
        } else if (year % 100 === 0) {
          return false;
        } else if (year % 4 === 0) {
          return true;
        } else {
          return false;
        }
      };
      daysInMonth = (function() {
        var DAYS_IN_MONTH;
        DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        return function(month, year) {
          var days;
          days = DAYS_IN_MONTH[month];
          if (month === 1 && isLeapYear(year)) {
            days++;
          }
          return days;
        };
      })();
      format = (function() {
        var MONTH_DAY_OF_YEAR, ch, dialHours, flag, isoWeek, pad, padding, paddings, specifiers, transforms, weekOfYear, _ref;
        MONTH_DAY_OF_YEAR = [1, 32, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
        weekOfYear = function(date, startOfWeek) {
          var day, diff, fields, nyd, remaining, week, weekStart;
          fields = [date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()];
          date = new Date(Date.UTC.apply(null, fields));
          nyd = new Date(Date.UTC(date.getUTCFullYear(), 0, 1));
          diff = (date.getTime() - nyd.getTime()) / DAY;
          day = date.getUTCDay();
          if (nyd.getUTCDay() === startOfWeek) {
            weekStart = 0;
          } else {
            weekStart = 7 - nyd.getUTCDay() + startOfWeek;
            if (weekStart === 8) {
              weekStart = 1;
            }
          }
          remaining = diff - weekStart;
          week = 0;
          if (diff >= weekStart) {
            week++;
            diff -= weekStart;
            week += Math.floor(diff / 7);
          }
          return week;
        };
        isoWeek = function(date) {
          var ny, nyd, nyy, offset, week;
          nyy = date.getUTCFullYear();
          nyd = new Date(Date.UTC(nyy, 0, 1)).getUTCDay();
          offset = nyd > 1 && nyd <= 4 ? 1 : 0;
          week = weekOfYear(date, 1) + offset;
          if (week === 0) {
            ny = new Date(Date.UTC(date.getUTCFullYear() - 1, 0, 1));
            nyd = ny.getUTCDay();
            nyy = ny.getUTCFullYear();
            week = nyd === 4 || (nyd === 3 && isLeapYear(nyy)) ? 53 : 52;
            return [week, date.getUTCFullYear() - 1];
          } else if (week === 53 && !(nyd === 4 || (nyd === 3 && isLeapYear(nyy)))) {
            return [1, date.getUTCFullYear() + 1];
          } else {
            return [week, date.getUTCFullYear()];
          }
        };
        dialHours = function(date) {
          var hours;
          hours = Math.floor(date.getUTCHours() % 12);
          if (hours === 0) {
            return 12;
          } else {
            return hours;
          }
        };
        specifiers = {
          a: function(date, locale) {
            return locale.day.abbrev[date.getUTCDay()];
          },
          A: function(date, locale) {
            return locale.day.full[date.getUTCDay()];
          },
          d: function(date) {
            return date.getUTCDate();
          },
          e: function(date) {
            return date.getUTCDate();
          },
          j: function(date) {
            var days, month;
            month = date.getUTCMonth();
            days = MONTH_DAY_OF_YEAR[month];
            if (month > 2 && isLeapYear(date.getUTCFullYear())) {
              days++;
            }
            days += date.getUTCDate() - 1;
            return days;
          },
          u: function(date) {
            var day;
            day = date.getUTCDay();
            if (day === 0) {
              day = 7;
            }
            return day;
          },
          w: function(date) {
            return date.getUTCDay();
          },
          U: function(date) {
            return weekOfYear(date, 0);
          },
          W: function(date) {
            return weekOfYear(date, 1);
          },
          V: function(date) {
            var iso;
            return iso = isoWeek(date)[0];
          },
          G: function(date) {
            var iso;
            return iso = isoWeek(date)[1];
          },
          g: function(date) {
            var iso;
            return iso = isoWeek(date)[1] % 100;
          },
          m: function(date) {
            return date.getUTCMonth() + 1;
          },
          h: function(date, locale) {
            return locale.month.abbrev[date.getUTCMonth()];
          },
          b: function(date, locale) {
            return locale.month.abbrev[date.getUTCMonth()];
          },
          B: function(date, locale) {
            return locale.month.full[date.getUTCMonth()];
          },
          y: function(date) {
            return date.getUTCFullYear() % 100;
          },
          Y: function(date) {
            return date.getUTCFullYear();
          },
          C: function(date) {
            return Math.floor(date.getFullYear() / 100);
          },
          D: function(date) {
            return tz(date, "%m/%d/%y");
          },
          x: function(date, locale, tzdata) {
            var utc;
            utc = convertToUTC(date.getTime(), tzdata);
            return tz(utc, locale.dateFormat, locale.name, tzdata.name);
          },
          F: function(date) {
            return tz(date, "%Y-%m-%d");
          },
          l: function(date) {
            return dialHours(date);
          },
          I: function(date) {
            return dialHours(date);
          },
          k: function(date) {
            return date.getUTCHours();
          },
          H: function(date) {
            return date.getUTCHours();
          },
          P: function(date, locale) {
            return locale.meridiem[Math.floor(date.getUTCHours() / 12)].lower;
          },
          p: function(date, locale) {
            return locale.meridiem[Math.floor(date.getUTCHours() / 12)].upper;
          },
          M: function(date) {
            return date.getUTCMinutes();
          },
          s: function(date) {
            return Math.floor(date.getTime() / 1000);
          },
          S: function(date) {
            return date.getUTCSeconds();
          },
          N: function(date) {
            return (date.getTime() % 1000) * 1000000;
          },
          r: function(date) {
            return tz(date, "%I:%M:%S %p");
          },
          R: function(date) {
            return tz(date, "%H:%M");
          },
          T: function(date) {
            return tz(date, "%H:%M:%S");
          },
          X: function(date, locale, tzdata) {
            var utc;
            utc = convertToUTC(date.getTime(), tzdata);
            return tz(utc, locale.timeFormat, locale.name, tzdata.name);
          },
          c: function(date, locale, tzdata) {
            var utc;
            utc = convertToUTC(date.getTime(), tzdata);
            return tz(utc, locale.dateTimeFormat, locale.name, tzdata.name);
          },
          z: function(date, locale, tzdata) {
            var offset;
            offset = Math.floor(offsetInMilliseconds(tzdata.offset) / 1000 / 60);
            if (offset < 0) {
              return "-" + (pad(Math.abs(offset), 4, "0"));
            } else {
              return pad(Math.abs(offset), 4, "0");
            }
          },
          Z: function() {
            return "UTC";
          }
        };
        padding = {
          d: 2,
          U: 2,
          W: 2,
          V: 2,
          g: 2,
          m: 2,
          j: 3,
          C: 2,
          I: 2,
          H: 2,
          k: 2,
          M: 2,
          S: 2,
          N: 9,
          y: 2
        };
        paddings = {
          "-": function(number) {
            return number;
          }
        };
        _ref = {
          "_": " ",
          "0": "0"
        };
        for (flag in _ref) {
          ch = _ref[flag];
          paddings[flag] = (function(ch) {
            return function(number, count) {
              return pad(number, count, ch);
            };
          })(ch);
        }
        pad = function(number, count, char) {
          var string;
          string = String(number);
          return "" + (new Array((count - string.length) + 1).join(char)) + string;
        };
        transforms = {
          none: function(value) {
            return value;
          },
          "^": function(value) {
            return value.toUpperCase();
          }
        };
        return function(wallclock, rest, locale, tzdata) {
          var date, flags, match, output, prefix, specifier, style, transform, value, _ref2;
          date = new Date(wallclock);
          output = [];
          while (rest.length) {
            match = /^(.*?)%(?:%|([-0_^]?)([aAcdDeFHIjklMNpPsrRSTuwXUWVmhbByYcGgCxzZ]))(.*)$/.exec(rest);
            if (match) {
              _ref2 = match.slice(1), prefix = _ref2[0], flags = _ref2[1], specifier = _ref2[2], rest = _ref2[3];
              if (specifier) {
                value = specifiers[specifier](date, locale, tzdata);
                if (padding[specifier]) {
                  style = specifier === "k" ? "_" : "0";
                  if (flags.length) {
                    if (paddings[flags[0]]) {
                      style = flags[0];
                    }
                  }
                  value = paddings[style](value, padding[specifier], tzdata);
                }
                transform = transforms.none;
                if (flags.length) {
                  transform = transforms[flags[0]] || transform;
                }
                value = transform(value);
                if (prefix != null) {
                  output.push(prefix);
                }
                output.push(value);
              } else {
                output.push("%");
              }
            } else if (rest.length) {
              output.push(rest);
              rest = "";
            }
          }
          return output.join("");
        };
      })();
      makeDate = (function() {
        var zeroUnless;
        zeroUnless = function(date, value) {
          if (value != null) {
            return date.push(parseInt(value, 10));
          } else {
            return date.push(0);
          }
        };
        return function(year, month, day, hours, minutes, seconds, milliseconds) {
          var date, now;
          date = [];
          if (!(year != null)) {
            now = new Date();
            date.push(now.getUTCFullYear());
          } else {
            date.push(parseInt(year, 10));
          }
          if (!(month != null)) {
            if (!(year != null)) {
              date.push(now.getUTCMonth());
            } else {
              date.push(0);
            }
          } else {
            date.push(parseInt(month, 10) - 1);
          }
          if (!(day != null)) {
            if (!(month != null)) {
              date.push(now.getUTCDate());
            } else {
              date.push(1);
            }
          } else {
            date.push(parseInt(day, 10));
          }
          zeroUnless(date, hours);
          zeroUnless(date, minutes);
          zeroUnless(date, seconds);
          zeroUnless(date, milliseconds);
          return Date.UTC.apply(null, date);
        };
      })();
      parse = function(pattern, locale) {
        var abbrev, after, before, date, day, dow, first, hours, i, made, match, milliseconds, minutes, month, num, offset, remaining, second, seconds, time, year, zone, zoneOffset, _i, _len, _len2, _ref, _ref10, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
        if (match = /^(.*?)(\w{3}),\s+(\d{1,2})\s+(\w{3})\s+(\d{2,4})\s+(\d{2}):(\d{2})(?::(\d{2}))?\s*(?:([A-IK-Z]|UT|GMT|[ECMP][SD]T)|([-+]?\d{4}))?(.*)$/i.exec(pattern)) {
          _ref = match.slice(1), before = _ref[0], dow = _ref[1], day = _ref[2], month = _ref[3], year = _ref[4], hours = _ref[5], minutes = _ref[6], seconds = _ref[7], zone = _ref[8], offset = _ref[9], after = _ref[10];
          dow = dow.toLowerCase();
          _ref2 = locale.day.abbrev;
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            abbrev = _ref2[_i];
            if (dow === abbrev.toLowerCase()) {
              dow = null;
              break;
            }
          }
          if (dow) {
            throw new Error("bad weekday");
          }
          month = month.toLowerCase();
          _ref3 = locale.month.abbrev;
          for (i = 0, _len2 = _ref3.length; i < _len2; i++) {
            abbrev = _ref3[i];
            if (month === abbrev.toLowerCase()) {
              month = i;
              break;
            }
          }
          if (typeof month === "string") {
            throw new Error("bad month");
          }
          seconds || (seconds = "0");
          offset || (offset = "0");
          _ref4 = (function() {
            var _j, _len3, _ref4, _results;
            _ref4 = [day, year, hours, minutes, seconds, offset];
            _results = [];
            for (_j = 0, _len3 = _ref4.length; _j < _len3; _j++) {
              num = _ref4[_j];
              _results.push(parseInt(num, 10));
            }
            return _results;
          })(), day = _ref4[0], year = _ref4[1], hours = _ref4[2], minutes = _ref4[3], seconds = _ref4[4], offset = _ref4[5];
          made = makeDate(year, month + 1, day, hours, minutes, seconds, 0);
          if (offset) {
            made -= Math.floor(offset / 100) * HOUR;
          }
          return made;
        }
        if (match = /^(.*?)(?:(\d\d\d\d)-(\d\d)(?:-(\d{2}))?|(\d{4})(\d{2})(\d{2})?)(?:(?:\s+|T)(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?)?(?:(?:\s+|Z)([+-]\d{2}(?::?\d{2})?))?(.*)$/.exec(pattern)) {
          before = match.splice(0, 2).pop();
          date = match.splice(0, 3);
          if (date[0] != null) {
            year = date[0], month = date[1], day = date[2];
          }
          date = match.splice(0, 3);
          if (date[0] != null) {
            year = date[0], month = date[1], day = date[2];
          }
          time = match.splice(0, 4);
          if (time[0] != null) {
            hours = time[0], minutes = time[1], seconds = time[2], milliseconds = time[3];
          }
          zone = match.shift();
          if (zone != null) {
            zoneOffset = offsetInMilliseconds(zone);
          }
          after = match.pop();
          remaining = (before + after).replace(/\s+/, "").length;
          if (remaining === 0) {
            return makeDate(year, month, day, hours, minutes, seconds, milliseconds);
          }
        }
        match = /^([^\u0000]*?)(\d{1,2})\/(\d{1,2})\/(\d{4})([^\u0000]*)$/.exec(pattern);
        if (match) {
          before = match.splice(0, 2).pop();
          _ref5 = (function() {
            var _j, _len3, _ref5, _results;
            _ref5 = match.splice(0, 3);
            _results = [];
            for (_j = 0, _len3 = _ref5.length; _j < _len3; _j++) {
              num = _ref5[_j];
              _results.push(parseInt(num, 10));
            }
            return _results;
          })(), first = _ref5[0], second = _ref5[1], year = _ref5[2];
          after = match.pop();
          if (locale.monthBeforeDate) {
            _ref6 = [first, second], month = _ref6[0], day = _ref6[1];
          } else {
            _ref7 = [first, second], day = _ref7[0], month = _ref7[1];
          }
          if (month > 12) {
            _ref8 = [month, day], day = _ref8[0], month = _ref8[1];
          }
        } else if (match = /^([^\u0000]*?)(\d{4})\/(\d{1,2})\/(\d{1,2})([^\u0000]*)$/.exec(pattern)) {
          before = match.splice(0, 2).pop();
          _ref9 = (function() {
            var _j, _len3, _ref9, _results;
            _ref9 = match.splice(0, 3);
            _results = [];
            for (_j = 0, _len3 = _ref9.length; _j < _len3; _j++) {
              num = _ref9[_j];
              _results.push(parseInt(num, 10));
            }
            return _results;
          })(), year = _ref9[0], month = _ref9[1], day = _ref9[2];
          after = match.pop();
        } else {
          _ref10 = ['', pattern], before = _ref10[0], after = _ref10[1];
        }
        if (after.length) {
          match = /(?:)/;
        }
        return makeDate(year, month, day, hours, minutes, seconds, milliseconds);
      };
      offsetInMilliseconds = function(pattern) {
        var hours, match, minutes, number, offset, seconds, sign, _ref;
        match = /^(-?)(\d)+(?::(\d)+)?(?::(\d+))?$/.exec(pattern).slice(1);
        match[0] += "1";
        _ref = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = match.length; _i < _len; _i++) {
            number = match[_i];
            _results.push(parseInt(number || "0", 10));
          }
          return _results;
        })(), sign = _ref[0], hours = _ref[1], minutes = _ref[2], seconds = _ref[3];
        offset = hours * HOUR;
        offset += minutes * MINUTE;
        offset += seconds * SECOND;
        offset *= sign;
        return offset;
      };
      ruleToDate = function(year, rule) {
        var date, day, hours, i, index, match, min, minutes, month, number, seconds, _len, _len2, _ref, _ref2, _ref3, _ref4;
        match = /^(\d)+:(\d)+(?:u?)?(?::(\d+))?$/.exec(rule.time).slice(1);
        _ref = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = match.length; _i < _len; _i++) {
            number = match[_i];
            _results.push(parseInt(number || 0, 10));
          }
          return _results;
        })(), hours = _ref[0], minutes = _ref[1], seconds = _ref[2];
        match = /^(?:(\d+)|last(\w+)|(\w+)>=(\d+))$/.exec(rule.day);
        if (match[1]) {
          _ref2 = [rule.month, parseInt(match[1], 10)], month = _ref2[0], day = _ref2[1];
          date = new Date(Date.UTC(year, month, day, hours, minutes, seconds));
        } else if (match[2]) {
          _ref3 = LOCALES.en_US.day.abbrev;
          for (i = 0, _len = _ref3.length; i < _len; i++) {
            day = _ref3[i];
            if (day === match[2]) {
              index = i;
              break;
            }
          }
          day = daysInMonth(rule.month, year);
          while (true) {
            date = new Date(Date.UTC(year, rule.month, day, hours, minutes, seconds));
            if (date.getDay() === index) {
              break;
            }
            day--;
          }
        } else {
          min = parseInt(match[4], 10);
          _ref4 = LOCALES.en_US.day.abbrev;
          for (i = 0, _len2 = _ref4.length; i < _len2; i++) {
            day = _ref4[i];
            if (day === match[3]) {
              index = i;
              break;
            }
          }
          day = 1;
          while (true) {
            date = new Date(Date.UTC(year, rule.month, day, hours, minutes, seconds));
            if (date.getDay() === index && date.getDate() >= min) {
              break;
            }
            day++;
          }
        }
        return date.getTime();
      };
      convertUntil = function(zone) {
        var field, fields;
        if (typeof zone.until !== "number") {
          if (zone.until != null) {
            fields = (function() {
              var _i, _len, _ref, _results;
              _ref = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}).000Z$/.exec(zone.until).slice(1);
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                field = _ref[_i];
                _results.push(parseInt(field, 10));
              }
              return _results;
            })();
            fields[1]--;
            zone.until = Date.UTC.apply(null, fields);
          } else {
            zone.until = Math.MAX_VALUE;
          }
        }
        return zone.until;
      };
      summerRule = function(wall, utc, zone) {
        var dst, offsetWall, previous, rule, rules, start, year, _i, _len;
        if (rules = TIMEZONES.rules[zone.rules]) {
          year = new Date(wall).getUTCFullYear();
          previous = new Date(year - 1, 11, 31).getTime();
          for (_i = 0, _len = rules.length; _i < _len; _i++) {
            rule = rules[_i];
            if (rule.from <= year && year <= rule.to) {
              start = ruleToDate(year, rule);
              offsetWall = wall;
              if (dst && utc) {
                offsetWall += offsetInMilliseconds(dst.save);
              }
              if (start <= offsetWall && previous < start) {
                previous = start;
                dst = rule;
              }
            }
          }
        }
        return dst;
      };
      convertToWallclock = function(utc, tzdata) {
        var dst, maybe, offset, wallclock, zone, _i, _len;
        for (_i = 0, _len = tzdata.length; _i < _len; _i++) {
          maybe = tzdata[_i];
          offset = utc + offsetInMilliseconds(maybe.offset);
          if (convertUntil(maybe) < offset) {
            break;
          }
          zone = maybe;
          wallclock = offset;
        }
        dst = summerRule(wallclock, true, zone);
        wallclock += offsetInMilliseconds((dst != null ? dst.save : void 0) || "0");
        return wallclock;
      };
      convertToUTC = function(wallclock, tzdata) {
        var dst, end, maybe, start, utc, zone, _i, _len;
        for (_i = 0, _len = tzdata.length; _i < _len; _i++) {
          maybe = tzdata[_i];
          if (convertUntil(maybe) < wallclock) {
            break;
          }
          zone = maybe;
        }
        utc = wallclock - offsetInMilliseconds(zone.offset);
        dst = summerRule(wallclock, false, zone);
        if (dst && dst.save !== "0") {
          start = ruleToDate(new Date(wallclock).getUTCFullYear(), dst);
          end = start + offsetInMilliseconds(dst.save);
          if (start <= wallclock && wallclock < end) {
            utc = null;
          } else {
            utc -= offsetInMilliseconds((dst != null ? dst.save : void 0) || "0");
          }
        }
        return utc;
      };
      adjust = (function() {
        var ASSIGNMENT, DAYS, FIELD, SIGN_OFFSET, TIME, explode;
        FIELD = {
          year: 0,
          month: 1,
          day: 2,
          hour: 3,
          minute: 4,
          second: 5,
          milli: 6
        };
        TIME = {
          milli: 1,
          second: SECOND,
          minute: MINUTE,
          hour: HOUR
        };
        SIGN_OFFSET = {
          "-": -1,
          "+": +1
        };
        DAYS = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
        ASSIGNMENT = {
          year: {
            min: 0,
            max: Number.MAX_VALUE
          },
          month: {
            min: 1,
            max: 12
          },
          day: {
            min: 1,
            max: 12
          }
        };
        explode = function(wallclock) {};
        return function(wallclock, adjustment, tzdata) {
          var count, date, fields, forward, increment, index, match, millis, month, offset, position, sign, unit, utc, _ref, _ref2;
          fields = explode(wallclock);
          match = /^\s*([+-]?)\s*(\d+)\s+(year|month|day|hour|minute|second|milli|sunday|monday|tuesday|wednesday|thursday|friday|saturday)s?\s*$/i.exec(adjustment);
          if (match) {
            _ref = match.slice(1), sign = _ref[0], count = _ref[1], unit = _ref[2];
            sign || (sign = "+");
            unit = unit.toLowerCase();
            increment = SIGN_OFFSET[sign];
            offset = parseInt(count, 10);
            if ((index = DAYS.indexOf(unit)) !== -1) {
              while (offset !== 0) {
                wallclock += increment * DAY;
                if (new Date(wallclock).getDay() === index) {
                  offset--;
                }
              }
            } else {
              if (millis = TIME[unit]) {
                utc = convertToUTC(wallclock, tzdata);
                utc += offset * increment * millis;
                wallclock = convertToWallclock(utc, tzdata);
              } else if (unit === "day") {
                wallclock += offset * increment * DAY;
              } else {
                date = new Date(wallclock);
                fields = [date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds()];
                if (unit === "month") {
                  while (offset !== 0) {
                    month = fields[FIELD.month];
                    if (month === 0 && offset < 0) {
                      fields[FIELD.month] = 11;
                      fields[FIELD.year]--;
                    } else if (month === 11 && offset > 0) {
                      fields[FIELD.month] = 0;
                      fields[FIELD.year]++;
                    } else {
                      fields[FIELD.month] += increment;
                    }
                    offset -= increment;
                  }
                }
                if (unit === "year") {
                  forward = offset / Math.abs(offset);
                  fields[FIELD.year] += offset;
                }
                wallclock = Date.UTC.apply(null, fields);
              }
            }
          } else if (match = /^\s*(year|month|day|hour|minute|second|milli|time|sunday|monday|tuesday|wednesday|thursday|friday|saturday)\s+(\d+)\s*$/.exec(adjustment)) {
            _ref2 = match.slice(1), unit = _ref2[0], position = _ref2[1];
            unit = unit.toLowerCase();
            date = new Date(wallclock);
            fields = [date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds()];
            switch (unit) {
              case "year":
                fields[FIELD.year] = position;
                adjustment = "0 year";
                break;
              case "month":
                if (position < 1) {
                  throw new Error("invalid month");
                }
                fields[FIELD.month] = 1;
                adjustment = "" + (position - 1) + " month";
                break;
              case "day":
                fields[FIELD.day] = 1;
                adjustment = "" + (position - 1) + " day";
                break;
              default:
                fields[FIELD[unit]] = 0;
                adjustment = "" + (position - 1) + " " + unit;
            }
            wallclock = Date.UTC.apply(null, fields);
            wallclock = adjust(wallclock, adjustment, tzdata);
          }
          if (!(convertToUTC(wallclock, tzdata) != null)) {
            wallclock += DAY * increment;
            utc = convertToUTC(wallclock, tzdata);
            utc -= DAY * increment;
            wallclock = convertToWallclock(utc, tzdata);
          }
          return wallclock;
        };
      })();
      exports.tz = tz = function() {
        var adjustment, argument, date, request, splat, token, wallclock, _i, _j, _len, _len2, _ref;
        date = arguments[0], splat = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (!(date != null)) {
          throw new Error("invalid arguments");
        }
        request = {
          adjustments: []
        };
        for (_i = 0, _len = splat.length; _i < _len; _i++) {
          argument = splat[_i];
          argument = String(argument);
          if (argument.indexOf("%") !== -1) {
            request.format || (request.format = argument);
          } else if (TIMEZONES.zones[argument]) {
            request.zone || (request.zone = argument);
          } else if (/^\w{2}_\w{2}$/.test(argument)) {
            if (!LOCALES[argument]) {
              throw new Error("unknown locale");
            }
            request.locale || (request.locale = argument);
          } else {
            request.adjustments.push(argument);
          }
        }
        request.locale || (request.locale = "en_US");
        request.zone || (request.zone = "UTC");
        request.tzdata = TIMEZONES.zones[request.zone];
        request.locale = LOCALES[request.locale];
        if (typeof date === "string") {
          wallclock = parse(date, request.locale, request.tzdata);
        } else {
          wallclock = date.getTime ? date.getTime() : date;
          if (request.zone !== "UTC") {
            wallclock = convertToWallclock(wallclock, request.tzdata);
          }
        }
        _ref = request.adjustments;
        for (_j = 0, _len2 = _ref.length; _j < _len2; _j++) {
          adjustment = _ref[_j];
          wallclock = adjust(wallclock, adjustment, request.tzdata);
        }
        if (request.format) {
          token = format(wallclock, request.format, request.locale, request.tzdata);
        } else if (request.zone !== "UTC") {
          token = convertToUTC(wallclock, request.tzdata);
        } else {
          token = wallclock;
        }
        return token;
      };
      tz.specialize = function() {
        var curried, k, self, splat, v;
        splat = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        self = this;
        curried = function() {
          var before;
          before = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return self.apply(null, before.concat(splat));
        };
        for (k in self) {
          v = self[k];
          curried[k] = v;
        }
        return curried;
      };
      tz.locales = function() {
        var locale, locales, _i, _len;
        locales = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        for (_i = 0, _len = locales.length; _i < _len; _i++) {
          locale = locales[_i];
          LOCALES[locale.name] = locale;
        }
        return LOCALES;
      };
      return tz.timezones = function(override) {
        var k, v, _ref, _ref2;
        if ((override != null ? override.zones : void 0) != null) {
          _ref = override.zones;
          for (k in _ref) {
            v = _ref[k];
            TIMEZONES.zones[k] = v;
            TIMEZONES.zones[k].name = k;
          }
          _ref2 = override != null ? override.rules : void 0;
          for (k in _ref2) {
            v = _ref2[k];
            TIMEZONES.rules[k] = v;
          }
        }
        return TIMEZONES;
      };
    })(exports);
  })();
}).call(this);
